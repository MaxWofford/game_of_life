# Building the Game of Life as a Ruby Gem

In this tutorial, we'll walk through a TDD-focused approach to building [Conway's Game of Life](http://en.wikipedia.org/wiki/Conway's_Game_of_Life) as a ruby gem. Unit tests and integration tests will be written in RSpec.

We'll be using Ruby 2.1.4 along with bundler, though any version >= 2.0.0 should work for our purposes. If you don't have bundler installed, `gem install bundler` will do the trick.

<h3>Sections</h3>
<a href="#bundler-bootstrap">Getting Started with Bundler</a><br>
<a href="#rspec-setup">RSpec setup</a><br>
<a href="#writing-tests">The Tests</a><br>
<a href="#time-to-code">The Code (and more tests)</a>

--

<br>
# <a name="bundler-bootstrap"></a>Using Bundler to Bootstrap your Gem

Bundler makes the initial setup of a gem painless. We'll stick with [standard gem naming conventions](http://guides.rubygems.org/name-your-gem/) and use underscores as spaces.

`bundle gem game_of_life`

You should see something like this:

```
create  game_of_life/Gemfile
create  game_of_life/Rakefile
create  game_of_life/LICENSE.txt
create  game_of_life/README.md
create  game_of_life/.gitignore
create  game_of_life/game_of_life.gemspec
create  game_of_life/lib/game_of_life.rb
create  game_of_life/lib/game_of_life/version.rb

Initializing git repo in <path>/game_of_life
```

The scaffolding is fairly straightforward -- bundler takes care of the proper directory structure, adding a README, initializing a git repository, and giving you some generic structure to build your gem.

There are two noteworthy here. First, let's take a look at our Gemfile.

#### Gemfile

```
source 'https://rubygems.org'

# Specify your gem's dependencies in game_of_life.gemspec
gemspec
```

#### game\_of\_life.gemspec

The `gemspec` line in your Gemfile tells bundler that we won't be using our Gemfile to manage dependencies; instead, we'll be using `game_of_life.gemspec`. Let's take a look at that.

```
# coding: utf-8
lib = File.expand_path('../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require 'game_of_life/version'

Gem::Specification.new do |spec|
  spec.name          = "game_of_life"
  spec.version       = GameOfLife::VERSION
  spec.authors       = ["Rob Cole"]
  spec.email         = ["email@example.com"]
  spec.summary       = %q{Game of Life as a Ruby Gem}
  spec.description   = %q{TDD Practice: Game of Life Ruby Gem}
  spec.homepage      = ""
  spec.license       = "MIT"

  spec.files         = `git ls-files -z`.split("\x0")
  spec.executables   = spec.files.grep(%r{^bin/}) { |f| File.basename(f) }
  spec.test_files    = spec.files.grep(%r{^(test|spec|features)/})
  spec.require_paths = ["lib"]

  spec.add_development_dependency "bundler", "~> 1.7"
  spec.add_development_dependency "rake", "~> 10.0"
  spec.add_development_dependency "rspec"
end
```

If you want to learn more about what each of these lines does and to learn more about building gems, I recommend [The Rubygems Guide to Making Your Own Gem](http://guides.rubygems.org/make-your-own-gem/) or for a very detailed read, [Brandon Hilkert's Learn to Build a Ruby Gem](http://brandonhilkert.com/books/build-a-ruby-gem/).

For our purposes, what we care about are setting the author, email, summary, description. We also need to add RSpec as a dependency to our project.

--

# <a name="rspec-setup""></a>Getting Started with RSpec


#### Adding RSpec

After you've added rspec to your gemspec file, you can run `bundle install`. You should see something like this, letting you know that rspec is now bundled with your project.

```
Fetching gem metadata from https://rubygems.org/.........
Resolving dependencies...
Using rake 10.3.2
Using bundler 1.7.3
Using diff-lcs 1.2.5
Using game_of_life 0.0.1 from source at .
Installing rspec-support 3.1.2
Installing rspec-core 3.1.7
Using rspec-expectations 3.1.2
Installing rspec-mocks 3.1.3
Using rspec 3.1.0
Your bundle is complete!
Use `bundle show [gemname]` to see where a bundled gem is installed.
```

#### RSpec Setup
Once you've got RSpec bundled with your project, run `rspec --init` to setup RSpec in your project. This will add a spec_helper, and a .rspec configuration file that will require it.

Edit your spec_helper file, and require your gem.

```
require "game_of_life"
# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
...
```

Voila! You're setup and are ready to start righting tests. To verify, you can run tests via ```rspec spec```.

```
$ rspec spec/
No examples found.

Finished in 0.0002 seconds (files took 0.13013 seconds to load)
```

Now we're ready to start writing tests.

--

# <a name="writing-tests"></a>It's Testing Time
For our version of the game, we'll model the game using Grids and Cells. A grid will be infinite.

To start, we'll create a `grid_spec.rb` file inside our `spec` directory. The basic template for our file will look like this:

```
require 'spec_helper'

module GameOfLife
  describe Grid do
    describe "#draw" do
      it "draws the grid" do
        skip("Not yet implemented")
      end
    end
  end
end
```

There are three important things to note here:

#### 1 - Namespacing
Because we're creating a gem, all code that we write will be namespaced under the GameOfLife module. This prevents conflicts if other libraries want to use the 

In order to call code from our gem, we'll prepend GameOfLife:: to any methods we call.

#### 2 - Syntax for setting pending tests
The line ```skip("Not yet implemented")``` allows us to build tests that we plan on implementing later. For now, we know that we want to test that grid.draw draws the grid, but we've got some work to do before we can get there... so we create a pending test, with the intention of coming back to it later.

#### 3 - "Describe" syntax conventions

In this case, we're describing what the "draw" method will do on a specific grid. For instance methods, it's recommended to use ```describe "#method_name"```, and for class methods, ```describe ".method_name"```. For more on this and other best practices for RSpec, check out [Better Specs](http://betterspecs.org/).

### Running our Tests

If we try to run our pending tests using `rspec spec`, they will fail with the following error:
```uninitialized constant GameOfLife::Grid (NameError)``` because our application doesn't have a Grid class yet. So let's create one.

--

# <a name="time-to-code"></a>Time to Code!

From here on out, we'll be working in a [Red-Green-Refactor](http://www.jamesshore.com/Blog/Red-Green-Refactor.html) style, starting with writing failing tests, then writing *just* enough code to make the tests pass, and eventually cleaning up our code (refactoring). We have our first failing test, 

## Part One: A Quick Look at Gem File Structure

We're going to start by editing `game_of_life/lib/game_of_life.rb`. We'll initially be cramming all of our code into a single file, but as our project grows, we will migrate code into separate files.

With that said, let's start with rule #1: **write just enough code to make the test pass.**

```
# game_of_life/lib/game_of_life.rb

require "game_of_life/version"

module GameOfLife
  class Grid
  end
end
```

Now, with our first non-failing test out of the way (just run `rspec spec` to verify), we can move on to writing some real tests and real code.

## Part Two: Real Code

Now we're ready to start implementing actual code. We'll be breaking the Game of Life down into two separate classes - Grids and Cells. Cells will be responsible for knowing their coordinates and their state (alive or dead). Grids will be able to find the nearest neighbors of a cell given a position, to create a new grid with a new pattern, and to calculate the next state for a given cell given its neighbors. A grid will also be able to call ```grid#draw``` in order to display itself.

### The Grid

Our first test will ensure that a new grid can be created. A grid will have many Cells, but we'll start with a single cell, located at [0, 0]. Grid will take an array of live cells in order to initialize the initial pattern.

```
# grid_spec.rb

require 'spec_helper'

module GameOfLife
  describe Grid do

    context "Grid is initialized with a single cell" do
      before(:each) do
        live_coordinates = [[0, 0]]
        @grid = GameOfLife::Grid.new(live_coordinates)
      end

      describe "#initialize" do
        expect(@grid.cells.first.position).to eq [0,0]
      end
    end

    describe "#draw" do
      it "draws the grid" do
        skip("Not yet implemented")
      end
    end
  end
end

```

We're using the context block to separate tests logically into different contextual segments. In this case, we're initializing a new grid with a single cell at 0,0 using the `before(:each)` syntax, and keeping that separated within the context of a single-cell grid. This will allow each text within that context block to access that specific instance of @grid.

Run your test suite, and you should see an error message: 
```
Failure/Error: @grid = GameOfLife::Grid.nfdew(live_coordinates)
     ArgumentError:
       wrong number of arguments (1 for 0)
     # ./spec/grid_spec.rb:9:in `initialize'
     # ./spec/grid_spec.rb:9:in `new'
     # ./spec/grid_spec.rb:9:in `block (3 levels) in <module:GameOfLife>'
```

### A Grid of Cells

We're starting with a fairly complex test to make pass. In order for it to pass, we need to ensure the following things happen:

**1** - We can pass an array (or multiple arrays) as an argument to our new grid.
<br>**2** - For each coordinate pair passed to the grid, a new cell is created.
<br>**3** - Each cell needs to respond to the method position, and return an array of its x, y coordinates.

Let's start with #1, which is our simplest step. In order to allow the user to pass **either** an array or multiple arrays to the grid, we'll set up an initialize method that uses [Ruby's splat operator](http://endofline.wordpress.com/2011/01/21/the-strange-ruby-splat/) to create an array from the arguments passed to it.

```
class Grid
  def initialize(*arr)
  end
end
```

In order for a grid to create and associate itself with cells, we'll need to have a Cell class as well. Each cell will accept its coordinates as arguments, and will have a default state of "live" on creation.

```
class Cell
  attr_accessor :position, :state

  def initialize(coordinates)
    @position = coordinates
    @state = :live
  end
end
```

The [`attr_accessor`](http://stackoverflow.com/questions/4370960/what-is-attr-accessor-in-ruby) method allows us to set and access the position of the cell by creating [setter and getter methods](http://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/45-more-classes/lessons/110-instance-variables). Now, we need to ensure that Grid will create a new Cell for each coordinate pair passed to it. For this, I'm using [ruby's Enumerable#map](http://ruby-doc.org/core-2.1.4/Enumerable.html#method-i-map), which takes the array of arrays and converts each one to a cell. Here's what it all looks like when it's all put together.

```
require "game_of_life/version"

module GameOfLife

  class Grid
    attr_accessor :cells
    def initialize(*arr)
      @cells = arr.map { |coords| Cell.new(coords) }
    end
  end

  class Cell
    attr_accessor :position, :state

    def initialize(coordinates)
      @position = coordinates
      @state = :live
    end
  end

end
```

With that code written, we can create a new test and context to ensure that if we pass multiple coordinates to a grid, it will work as well. Let's add that code to our `grid_spec.rb` file.

```
context "Grid is initialized with two cells" do
  before(:each) do
    @coord1 = [0,0]
    @coord2 = [1,1]
    @grid = GameOfLife::Grid.new(@coord1, @coord2)
  end

  describe "#initialize" do
    it "should have a first position of 0,0" do
      expect(@grid.cells.first.position).to eq @coord1
    end

    it "should have a second position of 1,1" do
      expect(@grid.cells[1].position).to eq @coord2
    end
  end
end
```

When you run `rspec spec`, you should have 3 passing tests and 1 pending test -- a working grid of cells!